# -*- coding: utf-8 -*-
"""WayToGo Model

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ssn8vdii0PHNFkAVj0IfALzecD1AE6-j
"""

pip install geopy

# Commented out IPython magic to ensure Python compatibility.
# Untuk pengolahan data
import pandas as pd
import numpy as np
from zipfile import ZipFile
from pathlib import Path

# Untuk visualisasi data
import seaborn as sns
import matplotlib.pyplot as plt

# %matplotlib inline
sns.set_palette('Set1')
sns.set()

# Untuk pemodelan
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from sklearn.model_selection import train_test_split
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics.pairwise import haversine_distances
from sklearn.metrics import mean_absolute_error
from geopy.geocoders import Nominatim
from geopy.geocoders import GoogleV3

# Untuk menghilangkan warnings saat plotting seaborn
import warnings
warnings.filterwarnings('ignore')

# Untuk mengupload file
from google.colab import files

# Upload semua dataset yang dipakai
uploaded = files.upload()

# Menyimpan dataset

dataset = pd.read_excel('WayToGo Dataset.xlsx')

# Melihat gambaran data

dataset.head(2)

# Membuang kolom yang tidak dipakai
kolom_yang_dibuang = ['formatted_phone_number','website', 'url']

dataset = dataset.drop(kolom_yang_dibuang, axis=1)

dataset.head(2)

geolocator = GoogleV3(api_key='AIzaSyD-ktXkaMsEdsxDQuMxJS0qit0O6GXvxQU')

# Fungsi untuk mendapatkan nama kecamatan, kabupaten, dan kota dari formatted_address
def get_location_details_from_address(address):
    location = geolocator.geocode(address, language='id')
    if location and location.raw.get('address_components'):
        location_details = {
            'kecamatan': '',
            'kabupaten': '',
            'kota': ''
        }
        for component in location.raw['address_components']:
            if 'administrative_area_level_3' in component['types']:
                location_details['kecamatan'] = component['long_name']
            elif 'administrative_area_level_2' in component['types']:
                location_details['kabupaten'] = component['long_name']
            elif 'locality' in component['types']:
                location_details['kota'] = component['long_name']

        # Membuat format output city_name
        formatted_output = f"{location_details['kecamatan']}, {location_details['kabupaten']}"
        if location_details['kota']:
            formatted_output = f"{location_details['kecamatan']}, {location_details['kabupaten']}, {location_details['kota']}"

        return formatted_output

    return None

# Menambahkan kolom city_name ke dalam dataset
dataset['city_name'] = dataset['formatted_address'].apply(get_location_details_from_address)

dataset.head(2)

# Mengecek apakah terdapat nilai NaN pada dataset
print(dataset.isnull().sum())

# Menghapus Baris yang Mengandung Nilai NaN
dataset.dropna(subset=['photo_reference', 'city_name'], inplace=True)

# Mengganti Nilai NaN dengan Nilai Rata-rata
mean_rating = dataset['rating'].mean()
dataset['rating'].fillna(mean_rating, inplace=True)

# Memeriksa kembali dataset
print(dataset.isnull().sum())

dataset.head(2)

# Mengganti photo_reference dengan URL
dataset['photo_reference'] = 'https://maps.googleapis.com/maps/api/place/photo?maxwidth=400&photo_reference=' + dataset['photo_reference'] + '&key=AIzaSyD-ktXkaMsEdsxDQuMxJS0qit0O6GXvxQU'

dataset.head(2)

# Statistik deskriptif dataset
print(dataset.describe())

# Memisahkan fitur dan target
X_location = dataset[['lat', 'lng']]
X_rating = dataset[['rating']]
y = dataset['rating']

# Membagi dataset menjadi set pelatihan dan set pengujian
X_loc_train, X_loc_test, X_rating_train, X_rating_test, y_train, y_test = train_test_split(
    X_location, X_rating, y, test_size=0.2, random_state=42
)

# Normalisasi fitur menggunakan StandardScaler
scaler_location = StandardScaler()
X_loc_train_scaled = scaler_location.fit_transform(X_loc_train)
X_loc_test_scaled = scaler_location.transform(X_loc_test)

# Membangun model regresi linier dengan TensorFlow
model_rating = tf.keras.Sequential([
    tf.keras.layers.Input(shape=(2,), name='input_location'),
    tf.keras.layers.Dense(16, activation='relu'),
    tf.keras.layers.Dense(1, activation='linear', name='output_rating')
])

# Menentukan optimizer, fungsi loss, dan metrik evaluasi
model_rating.compile(optimizer='adam', loss='mean_squared_error', metrics=['mae'])

# Melatih model rating pada set pelatihan
history = model_rating.fit(X_loc_train_scaled, X_rating_train, validation_data=(X_loc_test_scaled, X_rating_test), epochs=50, batch_size=32, verbose=1)

# Evaluasi performa model rating pada set pengujian
rating_predictions = model_rating.predict(X_loc_test_scaled)
mae_rating = mean_absolute_error(X_rating_test, rating_predictions)
print(f'Mean Absolute Error (Rating): {mae_rating}')

# Menampilkan plot loss dan validation
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Training and Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.show()

# Hitung jarak dari lokasi pengguna ke setiap tempat menggunakan haversine distance
def haversine_vectorize(lon1, lat1, lon2, lat2):
    lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2])

    newlon = lon2 - lon1
    newlat = lat2 - lat1

    haversine = np.sin(newlat / 2.0) ** 2 + np.cos(lat1) * np.cos(lat2) * np.sin(newlon / 2.0) ** 2

    dist = 2 * np.arcsin(np.sqrt(haversine))
    km = 6367 * dist  # 6367 is the radius of the Earth in kilometers

    return km

# Fungsi untuk merekomendasikan tempat berdasarkan jarak dan rating
def recommend_places(user_location, dataset, max_distance=10, top_k_distance=5, top_k_rating=5):
    # Hitung jarak dari lokasi pengguna ke setiap tempat
    dataset['distance'] = haversine_vectorize(user_location[1], user_location[0], dataset['lng'], dataset['lat'])

    # Filter tempat dengan jarak kurang dari atau sama dengan max_distance
    nearby_places = dataset[dataset['distance'] <= max_distance]

    # Jika tidak ada tempat di dalam radius, kembalikan pesan
    if nearby_places.empty:
        return "Tidak ada tempat di dalam radius jarak yang ditentukan."

    # Sort tempat berdasarkan jarak terdekat
    nearest_places = nearby_places.sort_values(by='distance').head(top_k_distance)

    # Sort seluruh tempat berdasarkan rating tertinggi
    top_rated_places = dataset.sort_values(by='rating', ascending=False).head(top_k_rating)

    return nearest_places[['place_id','name','city_name', 'photo_reference', 'distance']], top_rated_places[['place_id','name','city_name', 'photo_reference']]

# Contoh penggunaan
user_location = (-7.0, 107.5)  # Bisa diganti dengan lokasi pengguna yang sesuai
max_distance = 10  # Bisa diganti dengan radius jarak yang diinginkan
top_k_distance = 5  # Jumlah tempat terdekat yang ingin ditampilkan
top_k_rating = 5  # Jumlah tempat dengan rating tertinggi yang ingin ditampilkan

# Memanggil fungsi recommend_places untuk merekomendasikan tempat
nearest_places, top_rated_places = recommend_places(user_location, dataset, max_distance, top_k_distance, top_k_rating)

# Tampilkan hasil rekomendasi tempat terdekat dengan radius 10KM dari titik user
print("Popular in Your Area:")
print(nearest_places)

# Tampilkan hasil rekomendasi tempat dengan rating tertinggi se Jawa Barat
print("Popular Destination:")
print(top_rated_places)